<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Buried Treasure ‚Äî Encrypted Island Exploration on Arcium</title>
<link href="https://fonts.googleapis.com/css2?family=Space+Mono:wght@400;700&family=DM+Sans:wght@400;500;700&display=swap" rel="stylesheet">
<style>
  :root {
    --bg-deep: #0a0e17;
    --bg-card: #111827;
    --bg-tile: #1a2234;
    --bg-tile-hover: #243049;
    --border: #2a3a52;
    --accent: #38bdf8;
    --accent-glow: rgba(56, 189, 248, 0.3);
    --treasure: #fbbf24;
    --treasure-glow: rgba(251, 191, 36, 0.3);
    --trap: #f43f5e;
    --trap-glow: rgba(244, 63, 94, 0.3);
    --empty: #6b7280;
    --text: #e2e8f0;
    --text-dim: #94a3b8;
    --text-muted: #64748b;
    --success: #34d399;
    --buried: #a78bfa;
    --buried-glow: rgba(167, 139, 250, 0.3);
    --fog: #1e293b;
  }

  * { margin: 0; padding: 0; box-sizing: border-box; }

  body {
    background: var(--bg-deep);
    color: var(--text);
    font-family: 'DM Sans', sans-serif;
    min-height: 100vh;
    overflow-x: hidden;
  }

  /* Animated background */
  body::before {
    content: '';
    position: fixed;
    top: 0; left: 0; right: 0; bottom: 0;
    background: 
      radial-gradient(ellipse at 20% 50%, rgba(56, 189, 248, 0.04) 0%, transparent 60%),
      radial-gradient(ellipse at 80% 20%, rgba(167, 139, 250, 0.04) 0%, transparent 60%),
      radial-gradient(ellipse at 50% 80%, rgba(251, 191, 36, 0.03) 0%, transparent 60%);
    pointer-events: none;
    z-index: 0;
  }

  .app-container {
    position: relative;
    z-index: 1;
    max-width: 1400px;
    margin: 0 auto;
    padding: 20px;
  }

  /* HEADER */
  .header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 16px 24px;
    background: var(--bg-card);
    border: 1px solid var(--border);
    border-radius: 16px;
    margin-bottom: 20px;
    backdrop-filter: blur(12px);
  }

  .logo-section {
    display: flex;
    align-items: center;
    gap: 14px;
  }

  .logo-icon {
    width: 44px;
    height: 44px;
    background: linear-gradient(135deg, var(--accent), var(--buried));
    border-radius: 12px;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 22px;
  }

  .logo-text h1 {
    font-family: 'Space Mono', monospace;
    font-size: 20px;
    letter-spacing: -0.5px;
    background: linear-gradient(135deg, var(--accent), var(--treasure));
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
  }

  .logo-text span {
    font-size: 11px;
    color: var(--text-muted);
    letter-spacing: 2px;
    text-transform: uppercase;
  }

  .wallet-btn {
    padding: 10px 20px;
    border-radius: 10px;
    border: 1px solid var(--border);
    background: var(--bg-tile);
    color: var(--text);
    font-family: 'Space Mono', monospace;
    font-size: 13px;
    cursor: pointer;
    transition: all 0.2s;
    display: flex;
    align-items: center;
    gap: 8px;
  }

  .wallet-btn:hover {
    background: var(--bg-tile-hover);
    border-color: var(--accent);
    box-shadow: 0 0 20px var(--accent-glow);
  }

  .wallet-btn.connected {
    border-color: var(--success);
    background: rgba(52, 211, 153, 0.1);
  }

  .wallet-dot {
    width: 8px; height: 8px;
    border-radius: 50%;
    background: var(--trap);
  }

  .wallet-dot.active { background: var(--success); }

  /* MAIN LAYOUT */
  .main-layout {
    display: grid;
    grid-template-columns: 280px 1fr 280px;
    gap: 20px;
    align-items: start;
  }

  @media (max-width: 1100px) {
    .main-layout {
      grid-template-columns: 1fr;
    }
  }

  /* PANELS */
  .panel {
    background: var(--bg-card);
    border: 1px solid var(--border);
    border-radius: 16px;
    padding: 20px;
  }

  .panel-title {
    font-family: 'Space Mono', monospace;
    font-size: 12px;
    letter-spacing: 2px;
    text-transform: uppercase;
    color: var(--text-muted);
    margin-bottom: 16px;
    display: flex;
    align-items: center;
    gap: 8px;
  }

  .panel-title::before {
    content: '';
    width: 3px;
    height: 14px;
    background: var(--accent);
    border-radius: 2px;
  }

  /* STATS */
  .stat-row {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 10px 0;
    border-bottom: 1px solid rgba(42, 58, 82, 0.5);
  }

  .stat-row:last-child { border-bottom: none; }

  .stat-label {
    font-size: 13px;
    color: var(--text-dim);
  }

  .stat-value {
    font-family: 'Space Mono', monospace;
    font-size: 14px;
    font-weight: 700;
  }

  .stat-value.treasure-color { color: var(--treasure); }
  .stat-value.trap-color { color: var(--trap); }
  .stat-value.accent-color { color: var(--accent); }
  .stat-value.buried-color { color: var(--buried); }

  /* GRID */
  .grid-container {
    position: relative;
  }

  .grid-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 16px;
  }

  .grid-header h2 {
    font-family: 'Space Mono', monospace;
    font-size: 14px;
    color: var(--text-dim);
  }

  .mode-toggle {
    display: flex;
    gap: 4px;
    background: var(--bg-deep);
    border-radius: 8px;
    padding: 3px;
  }

  .mode-btn {
    padding: 6px 14px;
    border: none;
    border-radius: 6px;
    font-family: 'DM Sans', sans-serif;
    font-size: 12px;
    font-weight: 500;
    cursor: pointer;
    transition: all 0.2s;
    color: var(--text-muted);
    background: transparent;
  }

  .mode-btn.active {
    background: var(--bg-tile);
    color: var(--text);
    box-shadow: 0 2px 8px rgba(0,0,0,0.3);
  }

  .island-grid {
    display: grid;
    grid-template-columns: repeat(10, 1fr);
    gap: 3px;
    background: var(--bg-deep);
    border: 1px solid var(--border);
    border-radius: 12px;
    padding: 6px;
    aspect-ratio: 1;
  }

  .tile {
    position: relative;
    border-radius: 6px;
    cursor: pointer;
    transition: all 0.2s;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 16px;
    background: var(--fog);
    border: 1px solid transparent;
    aspect-ratio: 1;
  }

  .tile::after {
    content: '';
    position: absolute;
    inset: 0;
    border-radius: 6px;
    opacity: 0;
    transition: opacity 0.2s;
  }

  .tile:hover {
    transform: scale(1.05);
    z-index: 2;
    border-color: var(--accent);
    box-shadow: 0 0 16px var(--accent-glow);
  }

  .tile.player-here {
    border: 2px solid var(--accent);
    box-shadow: 0 0 20px var(--accent-glow);
    background: rgba(56, 189, 248, 0.15);
  }

  .tile.adjacent {
    border-color: rgba(56, 189, 248, 0.3);
    background: rgba(56, 189, 248, 0.05);
  }

  .tile.explored-empty {
    background: var(--bg-tile);
    border-color: rgba(107, 114, 128, 0.2);
  }

  .tile.explored-treasure {
    background: rgba(251, 191, 36, 0.08);
    border-color: rgba(251, 191, 36, 0.3);
  }

  .tile.explored-trap {
    background: rgba(244, 63, 94, 0.08);
    border-color: rgba(244, 63, 94, 0.3);
  }

  .tile.has-buried {
    background: rgba(167, 139, 250, 0.08);
    border-color: rgba(167, 139, 250, 0.3);
  }

  .tile.selected {
    border: 2px solid var(--treasure);
    box-shadow: 0 0 20px var(--treasure-glow);
  }

  .tile-coord {
    position: absolute;
    bottom: 1px;
    right: 3px;
    font-family: 'Space Mono', monospace;
    font-size: 7px;
    color: var(--text-muted);
    opacity: 0.4;
  }

  .tile-icon {
    font-size: 18px;
    filter: drop-shadow(0 0 4px rgba(0,0,0,0.5));
  }

  .tile-lock {
    font-size: 12px;
    opacity: 0.3;
  }

  /* ACTION PANEL */
  .action-section {
    margin-top: 16px;
  }

  .action-btn {
    width: 100%;
    padding: 12px;
    border-radius: 10px;
    border: 1px solid var(--border);
    font-family: 'DM Sans', sans-serif;
    font-size: 14px;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.25s;
    margin-bottom: 8px;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 8px;
  }

  .action-btn:disabled {
    opacity: 0.35;
    cursor: not-allowed;
  }

  .action-btn.explore {
    background: linear-gradient(135deg, rgba(56, 189, 248, 0.15), rgba(56, 189, 248, 0.05));
    color: var(--accent);
    border-color: rgba(56, 189, 248, 0.3);
  }

  .action-btn.explore:not(:disabled):hover {
    background: linear-gradient(135deg, rgba(56, 189, 248, 0.25), rgba(56, 189, 248, 0.1));
    box-shadow: 0 0 24px var(--accent-glow);
  }

  .action-btn.dig {
    background: linear-gradient(135deg, rgba(251, 191, 36, 0.15), rgba(251, 191, 36, 0.05));
    color: var(--treasure);
    border-color: rgba(251, 191, 36, 0.3);
  }

  .action-btn.dig:not(:disabled):hover {
    background: linear-gradient(135deg, rgba(251, 191, 36, 0.25), rgba(251, 191, 36, 0.1));
    box-shadow: 0 0 24px var(--treasure-glow);
  }

  .action-btn.bury {
    background: linear-gradient(135deg, rgba(167, 139, 250, 0.15), rgba(167, 139, 250, 0.05));
    color: var(--buried);
    border-color: rgba(167, 139, 250, 0.3);
  }

  .action-btn.bury:not(:disabled):hover {
    background: linear-gradient(135deg, rgba(167, 139, 250, 0.25), rgba(167, 139, 250, 0.1));
    box-shadow: 0 0 24px var(--buried-glow);
  }

  .action-btn.move {
    background: linear-gradient(135deg, rgba(52, 211, 153, 0.15), rgba(52, 211, 153, 0.05));
    color: var(--success);
    border-color: rgba(52, 211, 153, 0.3);
  }

  .action-btn.move:not(:disabled):hover {
    background: linear-gradient(135deg, rgba(52, 211, 153, 0.25), rgba(52, 211, 153, 0.1));
    box-shadow: 0 0 24px rgba(52, 211, 153, 0.3);
  }

  /* BURY INPUT */
  .bury-input-row {
    display: flex;
    gap: 8px;
    margin-bottom: 8px;
  }

  .bury-input {
    flex: 1;
    padding: 10px 14px;
    border-radius: 8px;
    border: 1px solid var(--border);
    background: var(--bg-deep);
    color: var(--text);
    font-family: 'Space Mono', monospace;
    font-size: 13px;
    outline: none;
    transition: border-color 0.2s;
  }

  .bury-input:focus {
    border-color: var(--buried);
  }

  /* EVENT LOG */
  .event-log {
    max-height: 300px;
    overflow-y: auto;
    scrollbar-width: thin;
    scrollbar-color: var(--border) transparent;
  }

  .log-entry {
    padding: 10px 12px;
    border-radius: 8px;
    margin-bottom: 6px;
    font-size: 12px;
    line-height: 1.5;
    border-left: 3px solid;
    background: rgba(26, 34, 52, 0.5);
  }

  .log-entry.info { border-color: var(--accent); }
  .log-entry.treasure { border-color: var(--treasure); }
  .log-entry.trap { border-color: var(--trap); }
  .log-entry.bury { border-color: var(--buried); }
  .log-entry.system { border-color: var(--text-muted); }
  .log-entry.move { border-color: var(--success); }

  .log-time {
    font-family: 'Space Mono', monospace;
    font-size: 10px;
    color: var(--text-muted);
    margin-bottom: 2px;
  }

  /* MPC STATUS */
  .mpc-status {
    display: flex;
    align-items: center;
    gap: 8px;
    padding: 10px 14px;
    border-radius: 8px;
    background: var(--bg-deep);
    margin-bottom: 12px;
    font-size: 12px;
  }

  .mpc-dot {
    width: 8px; height: 8px;
    border-radius: 50%;
    background: var(--success);
    animation: pulse 2s infinite;
  }

  @keyframes pulse {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.4; }
  }

  .mpc-processing .mpc-dot {
    background: var(--treasure);
    animation: pulse 0.5s infinite;
  }

  /* PRIVACY INDICATOR */
  .privacy-badge {
    display: inline-flex;
    align-items: center;
    gap: 6px;
    padding: 4px 10px;
    border-radius: 6px;
    font-size: 10px;
    font-family: 'Space Mono', monospace;
    letter-spacing: 1px;
    text-transform: uppercase;
  }

  .privacy-badge.encrypted {
    background: rgba(56, 189, 248, 0.1);
    color: var(--accent);
    border: 1px solid rgba(56, 189, 248, 0.2);
  }

  .privacy-badge.private {
    background: rgba(167, 139, 250, 0.1);
    color: var(--buried);
    border: 1px solid rgba(167, 139, 250, 0.2);
  }

  /* ARCHITECTURE SECTION */
  .arch-section {
    margin-top: 20px;
    background: var(--bg-card);
    border: 1px solid var(--border);
    border-radius: 16px;
    padding: 24px;
  }

  .arch-title {
    font-family: 'Space Mono', monospace;
    font-size: 14px;
    color: var(--text);
    margin-bottom: 20px;
    display: flex;
    align-items: center;
    gap: 10px;
  }

  .arch-title::before {
    content: '‚óà';
    color: var(--accent);
  }

  .arch-flow {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
    gap: 12px;
  }

  .arch-node {
    padding: 16px;
    border-radius: 10px;
    border: 1px solid var(--border);
    background: var(--bg-deep);
    text-align: center;
  }

  .arch-node-label {
    font-family: 'Space Mono', monospace;
    font-size: 11px;
    color: var(--accent);
    letter-spacing: 1px;
    text-transform: uppercase;
    margin-bottom: 8px;
  }

  .arch-node-desc {
    font-size: 12px;
    color: var(--text-dim);
    line-height: 1.5;
  }

  .arch-arrow {
    display: flex;
    align-items: center;
    justify-content: center;
    color: var(--text-muted);
    font-size: 18px;
  }

  /* TOOLTIP */
  .tooltip {
    position: fixed;
    padding: 8px 12px;
    background: var(--bg-card);
    border: 1px solid var(--border);
    border-radius: 8px;
    font-size: 11px;
    pointer-events: none;
    z-index: 100;
    box-shadow: 0 8px 24px rgba(0,0,0,0.4);
    max-width: 200px;
  }

  /* MODAL */
  .modal-overlay {
    position: fixed;
    inset: 0;
    background: rgba(0,0,0,0.7);
    backdrop-filter: blur(4px);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 200;
  }

  .modal {
    background: var(--bg-card);
    border: 1px solid var(--border);
    border-radius: 16px;
    padding: 32px;
    max-width: 500px;
    width: 90%;
  }

  .modal h3 {
    font-family: 'Space Mono', monospace;
    font-size: 18px;
    margin-bottom: 16px;
  }

  .modal p {
    font-size: 14px;
    color: var(--text-dim);
    line-height: 1.7;
    margin-bottom: 12px;
  }

  /* MPC COMPUTATION INDICATOR */
  .computing-overlay {
    position: absolute;
    inset: 0;
    background: rgba(10, 14, 23, 0.85);
    backdrop-filter: blur(4px);
    border-radius: 12px;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    z-index: 10;
  }

  .computing-spinner {
    width: 40px; height: 40px;
    border: 3px solid var(--border);
    border-top-color: var(--accent);
    border-radius: 50%;
    animation: spin 0.8s linear infinite;
    margin-bottom: 12px;
  }

  @keyframes spin {
    to { transform: rotate(360deg); }
  }

  .computing-text {
    font-family: 'Space Mono', monospace;
    font-size: 12px;
    color: var(--accent);
    letter-spacing: 1px;
  }

  /* TABS */
  .tab-row {
    display: flex;
    gap: 2px;
    margin-bottom: 16px;
    background: var(--bg-deep);
    border-radius: 8px;
    padding: 3px;
  }

  .tab-btn {
    flex: 1;
    padding: 8px;
    border: none;
    border-radius: 6px;
    font-family: 'DM Sans', sans-serif;
    font-size: 11px;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.2s;
    color: var(--text-muted);
    background: transparent;
    text-transform: uppercase;
    letter-spacing: 0.5px;
  }

  .tab-btn.active {
    background: var(--bg-tile);
    color: var(--text);
  }

  /* LEADERBOARD */
  .lb-row {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 8px 10px;
    border-radius: 6px;
    margin-bottom: 4px;
    font-size: 12px;
    background: var(--bg-deep);
  }

  .lb-row.you {
    border: 1px solid var(--accent);
    background: rgba(56, 189, 248, 0.05);
  }

  .lb-addr {
    font-family: 'Space Mono', monospace;
    font-size: 11px;
    color: var(--text-dim);
  }

  .lb-score {
    font-family: 'Space Mono', monospace;
    font-weight: 700;
    color: var(--treasure);
  }

  /* RESPONSIVE */
  @media (max-width: 1100px) {
    .main-layout {
      grid-template-columns: 1fr 1fr;
    }
    .grid-container {
      grid-column: 1 / -1;
      order: -1;
    }
  }

  @media (max-width: 700px) {
    .main-layout {
      grid-template-columns: 1fr;
    }
    .header {
      flex-direction: column;
      gap: 12px;
    }
    .island-grid {
      gap: 2px;
      padding: 4px;
    }
    .tile-coord { display: none; }
  }

  /* Scrollbar */
  ::-webkit-scrollbar { width: 6px; }
  ::-webkit-scrollbar-track { background: transparent; }
  ::-webkit-scrollbar-thumb { background: var(--border); border-radius: 3px; }
</style>
</head>
<body>

<div id="app" class="app-container"></div>

<script>
// ============================================================
// BURIED TREASURE ‚Äî ENCRYPTED ISLAND EXPLORATION ON ARCIUM
// Full game engine with simulated MPC integration layer
// ============================================================

// ---- GAME CONSTANTS ----
const GRID_SIZE = 10;
const TREASURE_COUNT = 15;
const TRAP_COUNT = 10;
const MAX_TREASURE_VALUE = 50;
const MAX_TRAP_DAMAGE = 30;
const STARTING_HEALTH = 100;
const STARTING_GOLD = 20;
const MPC_DELAY_MS = 1200;

// ---- TILE STATES ----
const TILE_UNKNOWN = 0;
const TILE_EMPTY = 1;
const TILE_TREASURE = 2;
const TILE_TRAP = 3;

// ---- GAME STATE (simulates encrypted state) ----
class EncryptedGameState {
  constructor() {
    // This would be encrypted on Arcium MPC nodes
    // Client NEVER sees this directly
    this._baseMap = [];
    this._buriedLoot = [];
    this._playerStates = new Map();
    this._initBaseMap();
  }

  _initBaseMap() {
    // Initialize 10x10 grid with encrypted base state
    for (let y = 0; y < GRID_SIZE; y++) {
      this._baseMap[y] = [];
      this._buriedLoot[y] = [];
      for (let x = 0; x < GRID_SIZE; x++) {
        this._baseMap[y][x] = { type: TILE_EMPTY, value: 0 };
        this._buriedLoot[y][x] = { hasBuried: false, amount: 0, buriedBy: null };
      }
    }

    // Place treasures
    let placed = 0;
    while (placed < TREASURE_COUNT) {
      const x = Math.floor(Math.random() * GRID_SIZE);
      const y = Math.floor(Math.random() * GRID_SIZE);
      if (this._baseMap[y][x].type === TILE_EMPTY && !(x === 0 && y === 0)) {
        this._baseMap[y][x] = {
          type: TILE_TREASURE,
          value: 5 + Math.floor(Math.random() * (MAX_TREASURE_VALUE - 5))
        };
        placed++;
      }
    }

    // Place traps
    placed = 0;
    while (placed < TRAP_COUNT) {
      const x = Math.floor(Math.random() * GRID_SIZE);
      const y = Math.floor(Math.random() * GRID_SIZE);
      if (this._baseMap[y][x].type === TILE_EMPTY && !(x === 0 && y === 0)) {
        this._baseMap[y][x] = {
          type: TILE_TRAP,
          value: 5 + Math.floor(Math.random() * (MAX_TRAP_DAMAGE - 5))
        };
        placed++;
      }
    }
  }

  registerPlayer(walletAddress) {
    if (!this._playerStates.has(walletAddress)) {
      this._playerStates.set(walletAddress, {
        x: 0, y: 0,
        gold: STARTING_GOLD,
        health: STARTING_HEALTH,
        explored: new Set(),
        buried: new Set(),
        tilesExplored: 0,
        treasuresFound: 0,
        trapsTriggered: 0,
        lootBuried: 0,
        lootDugUp: 0
      });
    }
    return this._playerStates.get(walletAddress);
  }

  // ---- MPC FUNCTIONS (these would run on Arcium nodes) ----

  async mpcMove(walletAddress, targetX, targetY) {
    // Simulates MPC verification:
    // 1. Decrypt player position
    // 2. Verify adjacency
    // 3. Update encrypted position
    // 4. Return success/failure (no position leaked)
    await this._simulateMPC();
    const player = this._playerStates.get(walletAddress);
    if (!player) return { success: false, error: 'Player not found' };

    const dx = Math.abs(player.x - targetX);
    const dy = Math.abs(player.y - targetY);
    if (dx > 1 || dy > 1 || (dx === 0 && dy === 0)) {
      return { success: false, error: 'Invalid move: not adjacent' };
    }
    if (targetX < 0 || targetX >= GRID_SIZE || targetY < 0 || targetY >= GRID_SIZE) {
      return { success: false, error: 'Out of bounds' };
    }

    player.x = targetX;
    player.y = targetY;
    return { success: true, position: { x: targetX, y: targetY } };
  }

  async mpcExplore(walletAddress, tileX, tileY) {
    // Simulates MPC:
    // 1. Verify player is adjacent to tile
    // 2. Decrypt tile from base map
    // 3. Re-encrypt result for player's key only
    // 4. Update encrypted inventory if treasure/trap
    // 5. Return result encrypted to player
    await this._simulateMPC();
    const player = this._playerStates.get(walletAddress);
    if (!player) return { success: false, error: 'Player not found' };

    const dx = Math.abs(player.x - tileX);
    const dy = Math.abs(player.y - tileY);
    if (dx > 1 || dy > 1) {
      return { success: false, error: 'Not adjacent' };
    }

    const tileKey = `${tileX},${tileY}`;
    if (player.explored.has(tileKey)) {
      return { success: false, error: 'Already explored' };
    }

    const tile = this._baseMap[tileY][tileX];
    player.explored.add(tileKey);
    player.tilesExplored++;

    if (tile.type === TILE_TREASURE) {
      player.gold += tile.value;
      player.treasuresFound++;
      return {
        success: true,
        result: 'treasure',
        amount: tile.value,
        message: `You found treasure! +${tile.value} gold`
      };
    } else if (tile.type === TILE_TRAP) {
      player.health = Math.max(0, player.health - tile.value);
      player.trapsTriggered++;
      return {
        success: true,
        result: 'trap',
        amount: tile.value,
        message: `You triggered a trap! -${tile.value} health`
      };
    } else {
      return {
        success: true,
        result: 'empty',
        amount: 0,
        message: 'This tile is empty.'
      };
    }
  }

  async mpcBury(walletAddress, tileX, tileY, amount) {
    // Simulates MPC:
    // 1. Verify player inventory >= amount
    // 2. Write encrypted loot data (not linkable to player by others)
    // 3. Deduct from encrypted inventory
    // 4. Return confirmation (no player-tile link exposed)
    await this._simulateMPC();
    const player = this._playerStates.get(walletAddress);
    if (!player) return { success: false, error: 'Player not found' };

    if (amount <= 0 || amount > player.gold) {
      return { success: false, error: 'Insufficient gold' };
    }

    const dx = Math.abs(player.x - tileX);
    const dy = Math.abs(player.y - tileY);
    if (dx > 1 || dy > 1) {
      return { success: false, error: 'Not adjacent' };
    }

    player.gold -= amount;
    player.lootBuried += amount;
    const tileKey = `${tileX},${tileY}`;
    player.buried.add(tileKey);

    // Write to buried loot layer (encrypted, no public link to player)
    this._buriedLoot[tileY][tileX] = {
      hasBuried: true,
      amount: (this._buriedLoot[tileY][tileX].amount || 0) + amount,
      buriedBy: walletAddress // In real MPC, this link is never exposed
    };

    return {
      success: true,
      message: `Buried ${amount} gold. No one can link this to you.`,
      newBalance: player.gold
    };
  }

  async mpcDig(walletAddress, tileX, tileY) {
    // Simulates MPC:
    // 1. Check base map layer + buried loot layer (both encrypted)
    // 2. Return combined result
    // 3. Update encrypted inventory
    // 4. Clear buried loot if found
    await this._simulateMPC();
    const player = this._playerStates.get(walletAddress);
    if (!player) return { success: false, error: 'Player not found' };

    const dx = Math.abs(player.x - tileX);
    const dy = Math.abs(player.y - tileY);
    if (dx > 1 || dy > 1) {
      return { success: false, error: 'Not adjacent' };
    }

    const buried = this._buriedLoot[tileY][tileX];
    const base = this._baseMap[tileY][tileX];

    let totalFound = 0;
    let results = [];

    // Check buried layer
    if (buried.hasBuried && buried.amount > 0) {
      totalFound += buried.amount;
      results.push(`Found buried loot: +${buried.amount} gold`);
      player.lootDugUp += buried.amount;
      this._buriedLoot[tileY][tileX] = { hasBuried: false, amount: 0, buriedBy: null };
    }

    // Check base layer (only if not already explored)
    const tileKey = `${tileX},${tileY}`;
    if (!player.explored.has(tileKey)) {
      player.explored.add(tileKey);
      player.tilesExplored++;
      if (base.type === TILE_TREASURE) {
        totalFound += base.value;
        player.treasuresFound++;
        results.push(`Found base treasure: +${base.value} gold`);
      } else if (base.type === TILE_TRAP) {
        player.health = Math.max(0, player.health - base.value);
        player.trapsTriggered++;
        results.push(`Triggered trap: -${base.value} health`);
      }
    }

    player.gold += totalFound;

    if (results.length === 0) {
      return { success: true, result: 'nothing', message: 'Nothing found here.', amount: 0 };
    }

    return {
      success: true,
      result: totalFound > 0 ? 'treasure' : 'trap',
      message: results.join(' | '),
      amount: totalFound
    };
  }

  getPlayerView(walletAddress) {
    const player = this._playerStates.get(walletAddress);
    if (!player) return null;
    return {
      x: player.x,
      y: player.y,
      gold: player.gold,
      health: player.health,
      explored: Array.from(player.explored),
      buried: Array.from(player.buried),
      stats: {
        tilesExplored: player.tilesExplored,
        treasuresFound: player.treasuresFound,
        trapsTriggered: player.trapsTriggered,
        lootBuried: player.lootBuried,
        lootDugUp: player.lootDugUp
      }
    };
  }

  getExploredTileInfo(walletAddress, tileX, tileY) {
    const player = this._playerStates.get(walletAddress);
    if (!player) return null;
    const key = `${tileX},${tileY}`;
    if (!player.explored.has(key)) return null;
    return this._baseMap[tileY][tileX];
  }

  async _simulateMPC() {
    return new Promise(resolve => {
      setTimeout(resolve, MPC_DELAY_MS + Math.random() * 400);
    });
  }
}

// ---- FAKE WALLET ----
class MockWalletAdapter {
  constructor() {
    this.connected = false;
    this.publicKey = null;
  }

  async connect() {
    // Simulate Phantom wallet connection
    await new Promise(r => setTimeout(r, 600));
    const chars = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';
    let addr = '';
    for (let i = 0; i < 44; i++) addr += chars[Math.floor(Math.random() * chars.length)];
    this.publicKey = addr;
    this.connected = true;
    return addr;
  }

  disconnect() {
    this.connected = false;
    this.publicKey = null;
  }

  shortenAddress() {
    if (!this.publicKey) return '';
    return this.publicKey.slice(0, 4) + '...' + this.publicKey.slice(-4);
  }

  async signTransaction(txData) {
    // Simulate wallet signature
    await new Promise(r => setTimeout(r, 200));
    return { signature: 'sig_' + Math.random().toString(36).slice(2, 12), data: txData };
  }
}

// ---- LEADERBOARD (simulated other players) ----
const FAKE_PLAYERS = [
  { addr: '7xKf...a3Dm', gold: 145, explored: 34 },
  { addr: '3pRn...vQ8e', gold: 98, explored: 27 },
  { addr: 'BcYw...mN5j', gold: 72, explored: 19 },
  { addr: '9kTu...fL2s', gold: 56, explored: 15 },
];

// ============================================================
// APP
// ============================================================
const gameState = new EncryptedGameState();
const wallet = new MockWalletAdapter();

let state = {
  walletConnected: false,
  walletAddress: null,
  playerView: null,
  selectedTile: null,
  mode: 'explore', // explore | bury | dig
  buryAmount: '',
  computing: false,
  computingAction: '',
  eventLog: [],
  rightTab: 'log', // log | arch | leaderboard
  showWelcome: false,
};

function addLog(type, message) {
  const now = new Date();
  const time = now.toLocaleTimeString('en-US', { hour12: false, hour: '2-digit', minute: '2-digit', second: '2-digit' });
  state.eventLog.unshift({ type, message, time });
  if (state.eventLog.length > 50) state.eventLog.pop();
}

function isAdjacent(px, py, tx, ty) {
  return Math.abs(px - tx) <= 1 && Math.abs(py - ty) <= 1 && !(px === tx && py === ty);
}

async function connectWallet() {
  try {
    const addr = await wallet.connect();
    gameState.registerPlayer(addr);
    state.walletConnected = true;
    state.walletAddress = addr;
    state.playerView = gameState.getPlayerView(addr);
    state.showWelcome = true;
    addLog('system', `Wallet connected: ${wallet.shortenAddress()}`);
    addLog('info', 'MPC base map initialized ‚Äî 100 tiles encrypted on Arcium');
    addLog('system', 'You are at tile (0,0). Explore adjacent tiles to begin.');
    render();
  } catch (e) {
    addLog('system', 'Wallet connection failed');
    render();
  }
}

async function handleMove(tx, ty) {
  if (state.computing) return;
  state.computing = true;
  state.computingAction = 'MPC: Verifying adjacency...';
  render();

  const signed = await wallet.signTransaction({ action: 'move', x: tx, y: ty });
  addLog('info', `Signed move tx ‚Üí Arcium MPC cluster`);

  const result = await gameState.mpcMove(state.walletAddress, tx, ty);
  if (result.success) {
    state.playerView = gameState.getPlayerView(state.walletAddress);
    state.selectedTile = null;
    addLog('move', `Moved to (${tx}, ${ty})`);
  } else {
    addLog('system', `Move failed: ${result.error}`);
  }

  state.computing = false;
  render();
}

async function handleExplore() {
  if (!state.selectedTile || state.computing) return;
  const [tx, ty] = state.selectedTile;
  state.computing = true;
  state.computingAction = 'MPC: Decrypting tile for your eyes only...';
  render();

  const signed = await wallet.signTransaction({ action: 'explore', x: tx, y: ty });
  addLog('info', `Explore(${tx},${ty}) ‚Üí encrypted computation submitted`);

  const result = await gameState.mpcExplore(state.walletAddress, tx, ty);
  state.computing = false;

  if (result.success) {
    state.playerView = gameState.getPlayerView(state.walletAddress);
    if (result.result === 'treasure') {
      addLog('treasure', result.message);
    } else if (result.result === 'trap') {
      addLog('trap', result.message);
    } else {
      addLog('info', result.message);
    }
  } else {
    addLog('system', result.error);
  }
  render();
}

async function handleBury() {
  if (!state.selectedTile || state.computing) return;
  const amount = parseInt(state.buryAmount);
  if (isNaN(amount) || amount <= 0) {
    addLog('system', 'Enter a valid amount to bury');
    render();
    return;
  }

  const [tx, ty] = state.selectedTile;
  state.computing = true;
  state.computingAction = 'MPC: Encrypting burial with zero public linkage...';
  render();

  const signed = await wallet.signTransaction({ action: 'bury', x: tx, y: ty, amount });
  addLog('bury', `Bury(${tx},${ty}, ${amount}g) ‚Üí encrypted, no public link`);

  const result = await gameState.mpcBury(state.walletAddress, tx, ty, amount);
  state.computing = false;

  if (result.success) {
    state.playerView = gameState.getPlayerView(state.walletAddress);
    state.buryAmount = '';
    addLog('bury', result.message);
  } else {
    addLog('system', result.error);
  }
  render();
}

async function handleDig() {
  if (!state.selectedTile || state.computing) return;
  const [tx, ty] = state.selectedTile;
  state.computing = true;
  state.computingAction = 'MPC: Checking base + buried layers (encrypted)...';
  render();

  const signed = await wallet.signTransaction({ action: 'dig', x: tx, y: ty });
  addLog('info', `Dig(${tx},${ty}) ‚Üí dual-layer MPC check`);

  const result = await gameState.mpcDig(state.walletAddress, tx, ty);
  state.computing = false;

  if (result.success) {
    state.playerView = gameState.getPlayerView(state.walletAddress);
    if (result.result === 'treasure') {
      addLog('treasure', result.message);
    } else if (result.result === 'trap') {
      addLog('trap', result.message);
    } else {
      addLog('info', result.message);
    }
  } else {
    addLog('system', result.error);
  }
  render();
}

// ============================================================
// RENDER
// ============================================================
function render() {
  const app = document.getElementById('app');
  const pv = state.playerView;

  app.innerHTML = `
    <!-- HEADER -->
    <div class="header">
      <div class="logo-section">
        <div class="logo-icon">üèùÔ∏è</div>
        <div class="logo-text">
          <h1>Buried Treasure</h1>
          <span>Encrypted Island ‚Ä¢ Arcium MPC</span>
        </div>
      </div>
      <div style="display:flex;align-items:center;gap:12px;">
        <span class="privacy-badge encrypted">üîê MPC Encrypted State</span>
        <button class="wallet-btn ${state.walletConnected ? 'connected' : ''}" id="wallet-btn">
          <span class="wallet-dot ${state.walletConnected ? 'active' : ''}"></span>
          ${state.walletConnected ? wallet.shortenAddress() : 'Connect Phantom'}
        </button>
      </div>
    </div>

    ${!state.walletConnected ? renderLanding() : renderGame()}
  `;

  // Bind events
  document.getElementById('wallet-btn')?.addEventListener('click', () => {
    if (!state.walletConnected) connectWallet();
  });

  if (state.walletConnected) bindGameEvents();
}

function renderLanding() {
  return `
    <div style="max-width:700px;margin:60px auto;text-align:center;">
      <div style="font-size:64px;margin-bottom:24px;">üè¥‚Äç‚ò†Ô∏è</div>
      <h2 style="font-family:'Space Mono',monospace;font-size:28px;margin-bottom:16px;background:linear-gradient(135deg,var(--accent),var(--treasure));-webkit-background-clip:text;-webkit-text-fill-color:transparent;">
        Explore. Dig. Bury. Privately.
      </h2>
      <p style="color:var(--text-dim);font-size:16px;line-height:1.8;margin-bottom:32px;">
        A 10√ó10 island hides encrypted treasure and traps. Every tile's contents are computed inside 
        Arcium's MPC network ‚Äî <strong style="color:var(--text)">no one can read the map</strong>, not even the blockchain. 
        Only rule-required reveals reach your client. Your buried loot is unlinkable to your wallet.
      </p>
      <div style="display:grid;grid-template-columns:repeat(3,1fr);gap:16px;margin-bottom:40px;">
        <div class="panel" style="text-align:center;">
          <div style="font-size:28px;margin-bottom:8px;">üîç</div>
          <div style="font-family:'Space Mono',monospace;font-size:13px;color:var(--accent);margin-bottom:6px;">EXPLORE</div>
          <div style="font-size:12px;color:var(--text-dim);line-height:1.5;">MPC decrypts adjacent tiles for your eyes only. Others see nothing.</div>
        </div>
        <div class="panel" style="text-align:center;">
          <div style="font-size:28px;margin-bottom:8px;">‚õèÔ∏è</div>
          <div style="font-family:'Space Mono',monospace;font-size:13px;color:var(--treasure);margin-bottom:6px;">DIG</div>
          <div style="font-size:12px;color:var(--text-dim);line-height:1.5;">MPC checks base + buried layers and returns combined results.</div>
        </div>
        <div class="panel" style="text-align:center;">
          <div style="font-size:28px;margin-bottom:8px;">üíé</div>
          <div style="font-family:'Space Mono',monospace;font-size:13px;color:var(--buried);margin-bottom:6px;">BURY</div>
          <div style="font-size:12px;color:var(--text-dim);line-height:1.5;">Hide loot at any tile. MPC ensures zero public linkage to you.</div>
        </div>
      </div>
      <button class="wallet-btn" id="connect-landing-btn" style="margin:0 auto;padding:14px 32px;font-size:15px;">
        <span class="wallet-dot"></span>
        Connect Wallet to Play
      </button>
    </div>
    ${renderArchitecture()}
  `;
}

function renderGame() {
  const pv = state.playerView;
  if (!pv) return '';

  return `
    <div class="main-layout">
      <!-- LEFT PANEL: Player Stats -->
      <div>
        <div class="panel">
          <div class="panel-title">Player State</div>
          <div class="mpc-status ${state.computing ? 'mpc-processing' : ''}">
            <span class="mpc-dot"></span>
            <span style="font-family:'Space Mono',monospace;color:var(--text-dim);">
              ${state.computing ? state.computingAction : 'MPC cluster idle'}
            </span>
          </div>
          <div class="stat-row">
            <span class="stat-label">üí∞ Gold</span>
            <span class="stat-value treasure-color">${pv.gold}</span>
          </div>
          <div class="stat-row">
            <span class="stat-label">‚ù§Ô∏è Health</span>
            <span class="stat-value trap-color">${pv.health}/${STARTING_HEALTH}</span>
          </div>
          <div class="stat-row">
            <span class="stat-label">üìç Position</span>
            <span class="stat-value accent-color">(${pv.x}, ${pv.y})</span>
          </div>
          <div class="stat-row">
            <span class="stat-label">üó∫Ô∏è Explored</span>
            <span class="stat-value">${pv.stats.tilesExplored}/100</span>
          </div>
          <div class="stat-row">
            <span class="stat-label">üíé Treasures</span>
            <span class="stat-value treasure-color">${pv.stats.treasuresFound}</span>
          </div>
          <div class="stat-row">
            <span class="stat-label">üíÄ Traps Hit</span>
            <span class="stat-value trap-color">${pv.stats.trapsTriggered}</span>
          </div>
          <div class="stat-row">
            <span class="stat-label">ü™¶ Loot Buried</span>
            <span class="stat-value buried-color">${pv.stats.lootBuried}</span>
          </div>
        </div>

        <!-- ACTIONS -->
        <div class="panel" style="margin-top:12px;">
          <div class="panel-title">Actions</div>

          <div class="mode-toggle" style="margin-bottom:12px;">
            <button class="mode-btn ${state.mode === 'explore' ? 'active' : ''}" data-mode="explore">üîç Explore</button>
            <button class="mode-btn ${state.mode === 'dig' ? 'active' : ''}" data-mode="dig">‚õèÔ∏è Dig</button>
            <button class="mode-btn ${state.mode === 'bury' ? 'active' : ''}" data-mode="bury">üíé Bury</button>
          </div>

          ${state.selectedTile ? `
            <div style="font-size:12px;color:var(--text-dim);margin-bottom:10px;font-family:'Space Mono',monospace;">
              Selected: (${state.selectedTile[0]}, ${state.selectedTile[1]})
            </div>
          ` : `
            <div style="font-size:12px;color:var(--text-muted);margin-bottom:10px;">
              Click an adjacent tile to select it
            </div>
          `}

          ${state.mode === 'explore' ? `
            <button class="action-btn explore" id="btn-explore" ${!state.selectedTile || state.computing ? 'disabled' : ''}>
              üîç Explore Tile
            </button>
            <div style="font-size:11px;color:var(--text-muted);line-height:1.5;">
              MPC decrypts this tile for your wallet only. Base map contents are revealed without exposing the full grid.
            </div>
          ` : ''}

          ${state.mode === 'dig' ? `
            <button class="action-btn dig" id="btn-dig" ${!state.selectedTile || state.computing ? 'disabled' : ''}>
              ‚õèÔ∏è Dig Here
            </button>
            <div style="font-size:11px;color:var(--text-muted);line-height:1.5;">
              MPC checks <strong>both</strong> base map and buried loot layers. Returns combined result without revealing layer sources.
            </div>
          ` : ''}

          ${state.mode === 'bury' ? `
            <div class="bury-input-row">
              <input type="number" class="bury-input" id="bury-amount" placeholder="Gold amount" min="1" max="${pv.gold}" value="${state.buryAmount}">
            </div>
            <button class="action-btn bury" id="btn-bury" ${!state.selectedTile || state.computing ? 'disabled' : ''}>
              üíé Bury Loot
            </button>
            <div style="font-size:11px;color:var(--text-muted);line-height:1.5;">
              MPC writes encrypted data. <span style="color:var(--buried);">No public linkage</span> between your wallet and the burial site.
            </div>
          ` : ''}
        </div>
      </div>

      <!-- CENTER: GRID -->
      <div class="grid-container">
        <div class="grid-header">
          <h2>üèùÔ∏è Island Grid (10√ó10 encrypted matrix)</h2>
          <span class="privacy-badge private">üîí ${100 - pv.stats.tilesExplored} tiles hidden</span>
        </div>
        <div style="position:relative;">
          <div class="island-grid">
            ${renderGrid()}
          </div>
          ${state.computing ? `
            <div class="computing-overlay">
              <div class="computing-spinner"></div>
              <div class="computing-text">${state.computingAction}</div>
            </div>
          ` : ''}
        </div>
        <div style="display:flex;gap:12px;margin-top:12px;flex-wrap:wrap;">
          <div style="display:flex;align-items:center;gap:6px;font-size:11px;color:var(--text-muted);">
            <div style="width:12px;height:12px;background:var(--fog);border-radius:3px;border:1px solid var(--border);"></div> Unknown (encrypted)
          </div>
          <div style="display:flex;align-items:center;gap:6px;font-size:11px;color:var(--text-muted);">
            <div style="width:12px;height:12px;background:rgba(56,189,248,0.15);border-radius:3px;border:1px solid rgba(56,189,248,0.4);"></div> Your position
          </div>
          <div style="display:flex;align-items:center;gap:6px;font-size:11px;color:var(--text-muted);">
            <div style="width:12px;height:12px;background:rgba(251,191,36,0.1);border-radius:3px;border:1px solid rgba(251,191,36,0.3);"></div> Treasure
          </div>
          <div style="display:flex;align-items:center;gap:6px;font-size:11px;color:var(--text-muted);">
            <div style="width:12px;height:12px;background:rgba(244,63,94,0.1);border-radius:3px;border:1px solid rgba(244,63,94,0.3);"></div> Trap
          </div>
          <div style="display:flex;align-items:center;gap:6px;font-size:11px;color:var(--text-muted);">
            <div style="width:12px;height:12px;background:rgba(167,139,250,0.1);border-radius:3px;border:1px solid rgba(167,139,250,0.3);"></div> You buried loot
          </div>
        </div>
      </div>

      <!-- RIGHT PANEL -->
      <div>
        <div class="panel">
          <div class="tab-row">
            <button class="tab-btn ${state.rightTab === 'log' ? 'active' : ''}" data-tab="log">Event Log</button>
            <button class="tab-btn ${state.rightTab === 'leaderboard' ? 'active' : ''}" data-tab="leaderboard">Board</button>
            <button class="tab-btn ${state.rightTab === 'arch' ? 'active' : ''}" data-tab="arch">How MPC</button>
          </div>

          ${state.rightTab === 'log' ? `
            <div class="event-log">
              ${state.eventLog.map(e => `
                <div class="log-entry ${e.type}">
                  <div class="log-time">${e.time}</div>
                  <div>${e.message}</div>
                </div>
              `).join('')}
              ${state.eventLog.length === 0 ? '<div style="font-size:12px;color:var(--text-muted);text-align:center;padding:20px;">No events yet</div>' : ''}
            </div>
          ` : ''}

          ${state.rightTab === 'leaderboard' ? `
            <div style="margin-bottom:8px;font-size:11px;color:var(--text-muted);">
              Scores are public. Positions and strategies stay encrypted.
            </div>
            ${pv ? `
              <div class="lb-row you">
                <span class="lb-addr">${wallet.shortenAddress()} (you)</span>
                <span class="lb-score">${pv.gold}g</span>
              </div>
            ` : ''}
            ${FAKE_PLAYERS.map(p => `
              <div class="lb-row">
                <span class="lb-addr">${p.addr}</span>
                <span class="lb-score">${p.gold}g</span>
              </div>
            `).join('')}
          ` : ''}

          ${state.rightTab === 'arch' ? renderHowMPC() : ''}
        </div>
      </div>
    </div>

    ${renderArchitecture()}

    ${state.showWelcome ? renderWelcomeModal() : ''}
  `;
}

function renderGrid() {
  const pv = state.playerView;
  if (!pv) return '';

  let html = '';
  const exploredSet = new Set(pv.explored);
  const buriedSet = new Set(pv.buried);

  for (let y = 0; y < GRID_SIZE; y++) {
    for (let x = 0; x < GRID_SIZE; x++) {
      const isPlayer = pv.x === x && pv.y === y;
      const adj = isAdjacent(pv.x, pv.y, x, y);
      const key = `${x},${y}`;
      const isExplored = exploredSet.has(key);
      const isBuried = buriedSet.has(key);
      const isSelected = state.selectedTile && state.selectedTile[0] === x && state.selectedTile[1] === y;

      let tileClass = 'tile';
      let icon = '<span class="tile-lock">üîí</span>';

      if (isPlayer) {
        tileClass += ' player-here';
        icon = 'üß≠';
      } else if (isExplored) {
        const info = gameState.getExploredTileInfo(state.walletAddress, x, y);
        if (info) {
          if (info.type === TILE_TREASURE) {
            tileClass += ' explored-treasure';
            icon = '<span class="tile-icon">üí∞</span>';
          } else if (info.type === TILE_TRAP) {
            tileClass += ' explored-trap';
            icon = '<span class="tile-icon">üíÄ</span>';
          } else {
            tileClass += ' explored-empty';
            icon = '<span style="opacity:0.3">¬∑</span>';
          }
        }
      } else if (isBuried) {
        tileClass += ' has-buried';
        icon = '<span class="tile-icon">üíé</span>';
      } else if (adj) {
        tileClass += ' adjacent';
        icon = '<span class="tile-lock" style="opacity:0.5">?</span>';
      }

      if (isSelected) tileClass += ' selected';

      html += `<div class="${tileClass}" data-x="${x}" data-y="${y}">${icon}<span class="tile-coord">${x},${y}</span></div>`;
    }
  }
  return html;
}

function renderHowMPC() {
  return `
    <div style="font-size:12px;color:var(--text-dim);line-height:1.7;">
      <div style="margin-bottom:10px;">
        <strong style="color:var(--accent);">Why Arcium MPC?</strong>
      </div>
      <div style="margin-bottom:8px;">
        On a normal blockchain, the entire game map would be <span style="color:var(--trap)">publicly readable</span>. 
        Anyone could look at the contract state and see every treasure location.
      </div>
      <div style="margin-bottom:8px;">
        With Arcium, the map exists as an <span style="color:var(--accent)">encrypted matrix</span> inside an MXE. 
        MPC nodes jointly compute the result of your actions without any single node seeing the data.
      </div>
      <div style="margin-bottom:8px;">
        <strong style="color:var(--buried);">Dual encrypted layers:</strong> The base map and buried loot are independent encrypted states. 
        Dig checks both in one MPC call ‚Äî the result combines them without revealing which layer contributed what.
      </div>
      <div>
        <strong style="color:var(--treasure);">Zero-linkage burial:</strong> When you bury loot, MPC writes encrypted data with no 
        public connection to your wallet. Other players can't tell who buried what or where.
      </div>
    </div>
  `;
}

function renderArchitecture() {
  return `
    <div class="arch-section">
      <div class="arch-title">System Architecture: Frontend ‚Üî Solana ‚Üî Arcium MPC</div>
      <div class="arch-flow">
        <div class="arch-node">
          <div class="arch-node-label">Client (React + TS)</div>
          <div class="arch-node-desc">
            Wallet-adapter connects Phantom. Player encrypts inputs with MXE public key via ECDH. 
            Signs tx and submits to Solana program. Never sees raw map data.
          </div>
        </div>
        <div class="arch-node">
          <div class="arch-node-label">Solana Program</div>
          <div class="arch-node-desc">
            Anchor program with <code style="color:var(--accent)">#[arcium_program]</code> macro. 
            Validates wallet signature, calls <code>queue_computation()</code> to invoke MPC instructions. 
            Stores only encrypted blobs + public event logs.
          </div>
        </div>
        <div class="arch-node">
          <div class="arch-node-label">Arcium MPC (MXE)</div>
          <div class="arch-node-desc">
            Arcis-compiled encrypted instructions run on Arx node cluster. 
            <code style="color:var(--accent)">Enc&lt;Mxe, MapMatrix&gt;</code> holds the full map. 
            Each function decrypts only what's needed, re-encrypts results for the requesting player.
          </div>
        </div>
        <div class="arch-node">
          <div class="arch-node-label">Callback ‚Üí Client</div>
          <div class="arch-node-desc">
            MPC result is emitted as a Solana event. Client's TS SDK catches the event, 
            decrypts with shared secret, and renders the result. Only this player can read it.
          </div>
        </div>
      </div>

      <div style="margin-top:20px;display:grid;grid-template-columns:repeat(auto-fit, minmax(280px, 1fr));gap:12px;">
        <div style="padding:16px;border-radius:10px;border:1px solid var(--border);background:var(--bg-deep);">
          <div style="font-family:'Space Mono',monospace;font-size:11px;color:var(--accent);margin-bottom:8px;">ENCRYPTED MAP INIT (Arcis/Rust)</div>
          <pre style="font-family:'Space Mono',monospace;font-size:10px;color:var(--text-dim);line-height:1.6;white-space:pre-wrap;overflow-x:auto;">use arcis_imports::*;

#[encrypted]
mod circuits {
  use arcis_imports::*;

  pub struct MapTile {
    tile_type: u8,  // 0=empty,1=treasure,2=trap
    value: u16,
  }

  pub struct MapMatrix {
    tiles: [MapTile; 100], // 10x10
  }

  #[instruction]
  pub fn init_map(
    seed: Enc&lt;Shared, u64&gt;
  ) -> Enc&lt;Mxe, MapMatrix&gt; {
    let s = seed.to_arcis();
    let mut map = MapMatrix { 
      tiles: [MapTile { tile_type: 0, value: 0 }; 100] 
    };
    // PRNG from seed places treasures/traps
    // Result encrypted to MXE key only
    Mxe.from_arcis(map)
  }
}</pre>
        </div>

        <div style="padding:16px;border-radius:10px;border:1px solid var(--border);background:var(--bg-deep);">
          <div style="font-family:'Space Mono',monospace;font-size:11px;color:var(--treasure);margin-bottom:8px;">EXPLORE INSTRUCTION (Arcis/Rust)</div>
          <pre style="font-family:'Space Mono',monospace;font-size:10px;color:var(--text-dim);line-height:1.6;white-space:pre-wrap;overflow-x:auto;">pub struct ExploreInput {
  player_x: u8, player_y: u8,
  target_x: u8, target_y: u8,
}

pub struct ExploreResult {
  tile_type: u8,
  value: u16,
}

#[instruction]
pub fn explore(
  input: Enc&lt;Shared, ExploreInput&gt;,
  map: Enc&lt;Mxe, MapMatrix&gt;,
  player: Shared,
) -> Enc&lt;Shared, ExploreResult&gt; {
  let i = input.to_arcis();
  let m = map.to_arcis();
  // Verify adjacency inside MPC
  let dx = abs_diff(i.player_x, i.target_x);
  let dy = abs_diff(i.player_y, i.target_y);
  assert!(dx <= 1 && dy <= 1);
  let idx = i.target_y as usize * 10 
          + i.target_x as usize;
  let tile = m.tiles[idx];
  player.from_arcis(ExploreResult {
    tile_type: tile.tile_type,
    value: tile.value,
  })
}</pre>
        </div>

        <div style="padding:16px;border-radius:10px;border:1px solid var(--border);background:var(--bg-deep);">
          <div style="font-family:'Space Mono',monospace;font-size:11px;color:var(--buried);margin-bottom:8px;">BURY INSTRUCTION (Arcis/Rust)</div>
          <pre style="font-family:'Space Mono',monospace;font-size:10px;color:var(--text-dim);line-height:1.6;white-space:pre-wrap;overflow-x:auto;">pub struct BuryInput {
  target_x: u8, target_y: u8,
  amount: u16,
}

pub struct BuriedLayer {
  loot: [u16; 100], // encrypted amounts
}

pub struct PlayerState {
  x: u8, y: u8,
  gold: u16, health: u16,
}

#[instruction]
pub fn bury(
  input: Enc&lt;Shared, BuryInput&gt;,
  player: Enc&lt;Mxe, PlayerState&gt;,
  buried: Enc&lt;Mxe, BuriedLayer&gt;,
) -> (Enc&lt;Mxe, PlayerState&gt;, 
      Enc&lt;Mxe, BuriedLayer&gt;) {
  let i = input.to_arcis();
  let mut p = player.to_arcis();
  let mut b = buried.to_arcis();
  assert!(p.gold >= i.amount);
  p.gold -= i.amount;
  let idx = i.target_y as usize * 10 
          + i.target_x as usize;
  b.loot[idx] += i.amount;
  // NO public link between player & tile
  (Mxe.from_arcis(p), Mxe.from_arcis(b))
}</pre>
        </div>

        <div style="padding:16px;border-radius:10px;border:1px solid var(--border);background:var(--bg-deep);">
          <div style="font-family:'Space Mono',monospace;font-size:11px;color:var(--success);margin-bottom:8px;">DIG INSTRUCTION (Dual Layer)</div>
          <pre style="font-family:'Space Mono',monospace;font-size:10px;color:var(--text-dim);line-height:1.6;white-space:pre-wrap;overflow-x:auto;">pub struct DigResult {
  found_type: u8,   // 0=nothing,1=loot,2=trap
  total_value: u16, // combined from both layers
}

#[instruction]
pub fn dig(
  input: Enc&lt;Shared, ExploreInput&gt;,
  map: Enc&lt;Mxe, MapMatrix&gt;,
  buried: Enc&lt;Mxe, BuriedLayer&gt;,
  mut player: Enc&lt;Mxe, PlayerState&gt;,
  requester: Shared,
) -> (Enc&lt;Shared, DigResult&gt;, 
      Enc&lt;Mxe, PlayerState&gt;,
      Enc&lt;Mxe, BuriedLayer&gt;) {
  let i = input.to_arcis();
  let m = map.to_arcis();
  let mut b = buried.to_arcis();
  let mut p = player.to_arcis();
  let idx = i.target_y as usize * 10 
          + i.target_x as usize;
  let base = m.tiles[idx];
  let buried_amt = b.loot[idx];
  let mut total = buried_amt;
  // Combine both encrypted layers
  if base.tile_type == 1 { 
    total += base.value; 
  }
  if base.tile_type == 2 {
    p.health -= base.value;
  }
  p.gold += total;
  b.loot[idx] = 0;
  (requester.from_arcis(DigResult { 
    found_type: base.tile_type,
    total_value: total 
  }), Mxe.from_arcis(p), Mxe.from_arcis(b))
}</pre>
        </div>
      </div>

      <div style="margin-top:20px;padding:20px;border-radius:10px;border:1px solid var(--border);background:var(--bg-deep);">
        <div style="font-family:'Space Mono',monospace;font-size:11px;color:var(--accent);margin-bottom:12px;letter-spacing:1px;">WHY THIS GAME IS IMPOSSIBLE WITHOUT MPC</div>
        <div style="display:grid;grid-template-columns:1fr 1fr;gap:16px;font-size:12px;line-height:1.7;">
          <div>
            <div style="color:var(--trap);font-weight:700;margin-bottom:6px;">‚ùå Normal Onchain Game</div>
            <div style="color:var(--text-dim);">
              Map stored as contract state ‚Üí anyone reads it with an explorer. 
              Buried loot creates a public tx linking wallet to tile. 
              Player positions visible in real-time. 
              No fog of war possible. Game is broken before it starts.
            </div>
          </div>
          <div>
            <div style="color:var(--success);font-weight:700;margin-bottom:6px;">‚úÖ With Arcium MPC</div>
            <div style="color:var(--text-dim);">
              Map is an <code>Enc&lt;Mxe, MapMatrix&gt;</code> ‚Äî unreadable by anyone, even validators. 
              Bury writes to encrypted layer with no player linkage. 
              Explore returns data encrypted to YOUR key only. 
              Two independent encrypted layers combined in one MPC call.
              True fog of war is finally possible onchain.
            </div>
          </div>
        </div>
      </div>
    </div>
  `;
}

function renderWelcomeModal() {
  return `
    <div class="modal-overlay" id="modal-overlay">
      <div class="modal">
        <h3 style="display:flex;align-items:center;gap:10px;">üè¥‚Äç‚ò†Ô∏è Welcome, Explorer</h3>
        <p>
          You've landed on an encrypted island. Your position is <strong>(0, 0)</strong> and you start with 
          <strong>${STARTING_GOLD} gold</strong> and <strong>${STARTING_HEALTH} health</strong>.
        </p>
        <p>
          The 10√ó10 grid contains hidden treasures and traps ‚Äî all encrypted inside Arcium's MPC network. 
          <strong>No one can read the map</strong>, including you. You must explore to discover what's hidden.
        </p>
        <p style="color:var(--accent);">
          <strong>How to play:</strong> Click adjacent tiles to select them, then use Explore, Dig, or Bury. 
          Click your current tile's neighbors to move.
        </p>
        <button class="action-btn move" id="close-modal" style="margin-top:8px;">
          üó∫Ô∏è Start Exploring
        </button>
      </div>
    </div>
  `;
}

function bindGameEvents() {
  // Tile clicks
  document.querySelectorAll('.tile').forEach(tile => {
    tile.addEventListener('click', () => {
      const x = parseInt(tile.dataset.x);
      const y = parseInt(tile.dataset.y);
      const pv = state.playerView;

      if (pv.x === x && pv.y === y) return; // clicking self

      if (isAdjacent(pv.x, pv.y, x, y)) {
        state.selectedTile = [x, y];
        render();
      }
    });

    tile.addEventListener('dblclick', () => {
      const x = parseInt(tile.dataset.x);
      const y = parseInt(tile.dataset.y);
      const pv = state.playerView;
      if (isAdjacent(pv.x, pv.y, x, y)) {
        handleMove(x, y);
      }
    });
  });

  // Mode toggles
  document.querySelectorAll('.mode-btn[data-mode]').forEach(btn => {
    btn.addEventListener('click', () => {
      state.mode = btn.dataset.mode;
      render();
    });
  });

  // Tab toggles
  document.querySelectorAll('.tab-btn[data-tab]').forEach(btn => {
    btn.addEventListener('click', () => {
      state.rightTab = btn.dataset.tab;
      render();
    });
  });

  // Action buttons
  document.getElementById('btn-explore')?.addEventListener('click', handleExplore);
  document.getElementById('btn-dig')?.addEventListener('click', handleDig);
  document.getElementById('btn-bury')?.addEventListener('click', handleBury);

  // Bury amount
  document.getElementById('bury-amount')?.addEventListener('input', (e) => {
    state.buryAmount = e.target.value;
  });

  // Modal
  document.getElementById('close-modal')?.addEventListener('click', () => {
    state.showWelcome = false;
    render();
  });
  document.getElementById('modal-overlay')?.addEventListener('click', (e) => {
    if (e.target.id === 'modal-overlay') {
      state.showWelcome = false;
      render();
    }
  });

  // Landing connect button
  document.getElementById('connect-landing-btn')?.addEventListener('click', () => {
    if (!state.walletConnected) connectWallet();
  });
}

// Initial render
render();
</script>
</body>
</html>
