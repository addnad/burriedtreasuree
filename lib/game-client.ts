import * as anchor from '@coral-xyz/anchor';
import {
  getMXEPublicKey,
  awaitComputationFinalization,
} from '@arcium-hq/client';

// Cipher may not be available in all versions of @arcium-hq/client
// We'll handle encryption via the API layer instead
type Cipher = any;
import {
  Connection,
  PublicKey,
  Keypair,
  SystemProgram,
} from '@solana/web3.js';

// Import program types (generated by Anchor)
// In production, these would come from target/types/buried_treasure.ts
// For now, we'll use a simplified interface

// Program ID - should be set via environment variable after deployment
// Using a valid placeholder public key (SystemProgram for now)
const PROGRAM_ID_STRING = process.env.NEXT_PUBLIC_PROGRAM_ID || SystemProgram.programId.toString();
let PROGRAM_ID: PublicKey;
try {
  PROGRAM_ID = new PublicKey(PROGRAM_ID_STRING);
} catch {
  // Fallback to SystemProgram if invalid
  PROGRAM_ID = SystemProgram.programId;
}

const RPC_URL = process.env.NEXT_PUBLIC_SOLANA_RPC_URL || 'https://api.mainnet-beta.solana.com';

export interface MoveResult {
  success: boolean;
  newX?: number;
  newY?: number;
  error?: string;
}

export interface ExploreResult {
  success: boolean;
  tileType?: 'empty' | 'treasure' | 'trap';
  value?: number;
  message?: string;
  error?: string;
}

export interface DigResult {
  success: boolean;
  foundType?: 'nothing' | 'treasure' | 'trap';
  totalValue?: number;
  healthLost?: number;
  message?: string;
  error?: string;
}

export interface BuryResult {
  success: boolean;
  newGold?: number;
  error?: string;
}

export interface PlayerState {
  x: number;
  y: number;
  gold: number;
  health: number;
  explored: string[];
  buried: string[];
  stats: {
    tilesExplored: number;
    treasuresFound: number;
    trapsTriggered: number;
    lootBuried: number;
    lootDugUp: number;
  };
}

export class BuriedTreasureClient {
  private connection: Connection;
  private provider: anchor.AnchorProvider;
  private program: any; // anchor.Program<BuriedTreasure>
  private cipher: Cipher | null = null;
  private clientKeypair: Keypair;
  private mxePublicKey: Uint8Array | null = null;
  private wallet: anchor.Wallet;

  constructor(wallet: anchor.Wallet) {
    this.wallet = wallet;
    this.connection = new Connection(RPC_URL, 'confirmed');
    this.provider = new anchor.AnchorProvider(this.connection, wallet, {
      commitment: 'confirmed',
    });
    anchor.setProvider(this.provider);
    
    // Generate ephemeral keypair for ECDH encryption with MXE
    this.clientKeypair = Keypair.generate();

    // In production, load the program IDL
    // For now, we'll use API calls to the backend
  }

  async initialize() {
    try {
      // Only try to fetch MXE public key if we have a valid program ID
      // For now, we'll skip this and use the API layer instead
      // In production, after deploying the program, set NEXT_PUBLIC_PROGRAM_ID
      if (PROGRAM_ID && PROGRAM_ID.toString() !== SystemProgram.programId.toString()) {
        try {
          // Fetch MXE public key for encryption
          this.mxePublicKey = await getMXEPublicKey(
            this.provider as anchor.AnchorProvider,
            PROGRAM_ID
          );

          // Initialize cipher with shared secret (ECDH between client and MXE)
          // Note: Cipher initialization handled via API layer
          if (this.mxePublicKey) {
            this.cipher = null; // API layer handles encryption
          }
        } catch (err) {
          console.warn('Could not initialize MPC cipher (program may not be deployed yet):', err);
          // Continue without cipher - API layer will handle encryption
        }
      } else {
        console.warn('Program ID not set. Using API layer for game actions.');
      }
    } catch (err) {
      console.error('Failed to initialize client:', err);
      // Don't throw - allow the app to work with API layer
    }
  }

  private encryptInput(data: Buffer): {
    ciphertext: Uint8Array[];
    nonce: anchor.BN;
    clientPublicKey: Uint8Array;
  } {
    // Encryption is handled via API layer
    // This method is kept for future MPC integration
    throw new Error('Direct encryption not available - use API layer');
  }

  private decryptResult(encryptedResult: Uint8Array): Buffer {
    // Decryption is handled via API layer
    // This method is kept for future MPC integration
    throw new Error('Direct decryption not available - use API layer');
  }

  async registerPlayer(): Promise<string> {
    // Call backend API to register player
    const response = await fetch('/api/game/register', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        wallet: this.wallet.publicKey.toString(),
      }),
    });

    if (!response.ok) {
      throw new Error('Failed to register player');
    }

    const data = await response.json();
    return data.tx;
  }

  async movePlayer(targetX: number, targetY: number): Promise<MoveResult> {
    try {
      const response = await fetch('/api/game/move', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          wallet: this.wallet.publicKey.toString(),
          targetX,
          targetY,
        }),
      });

      if (!response.ok) {
        const error = await response.json();
        return { success: false, error: error.message || 'Move failed' };
      }

      const data = await response.json();
      return {
        success: true,
        newX: data.newX,
        newY: data.newY,
      };
    } catch (err: any) {
      return { success: false, error: err.message || 'Move failed' };
    }
  }

  async explore(targetX: number, targetY: number): Promise<ExploreResult> {
    try {
      const response = await fetch('/api/game/explore', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          wallet: this.wallet.publicKey.toString(),
          targetX,
          targetY,
        }),
      });

      if (!response.ok) {
        const error = await response.json();
        return { success: false, error: error.message || 'Explore failed' };
      }

      const data = await response.json();
      return {
        success: true,
        tileType: data.tileType,
        value: data.value,
        message: data.message,
      };
    } catch (err: any) {
      return { success: false, error: err.message || 'Explore failed' };
    }
  }

  async dig(targetX: number, targetY: number): Promise<DigResult> {
    try {
      const response = await fetch('/api/game/dig', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          wallet: this.wallet.publicKey.toString(),
          targetX,
          targetY,
        }),
      });

      if (!response.ok) {
        const error = await response.json();
        return { success: false, error: error.message || 'Dig failed' };
      }

      const data = await response.json();
      return {
        success: true,
        foundType: data.foundType,
        totalValue: data.totalValue,
        healthLost: data.healthLost,
        message: data.message,
      };
    } catch (err: any) {
      return { success: false, error: err.message || 'Dig failed' };
    }
  }

  async bury(targetX: number, targetY: number, amount: number): Promise<BuryResult> {
    try {
      const response = await fetch('/api/game/bury', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          wallet: this.wallet.publicKey.toString(),
          targetX,
          targetY,
          amount,
        }),
      });

      if (!response.ok) {
        const error = await response.json();
        return { success: false, error: error.message || 'Bury failed' };
      }

      const data = await response.json();
      return {
        success: true,
        newGold: data.newGold,
      };
    } catch (err: any) {
      return { success: false, error: err.message || 'Bury failed' };
    }
  }

  async getPlayerState(): Promise<PlayerState | null> {
    try {
      const response = await fetch(`/api/game/state?wallet=${this.wallet.publicKey.toString()}`);
      
      if (!response.ok) {
        return null;
      }

      const data = await response.json();
      return data.state;
    } catch (err) {
      console.error('Failed to get player state:', err);
      return null;
    }
  }
}
